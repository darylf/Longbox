import { gql } from "@apollo/client";
import * as Apollo from "@apollo/client";

export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> &
  { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> &
  { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions = {};
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  DateTime: any;
};

/** A comic book or trade paperback */
export type Book = {
  __typename?: "Book";
  ageRating?: Maybe<Scalars["String"]>;
  alternateTitle?: Maybe<Scalars["String"]>;
  createdAt: Scalars["DateTime"];
  credits?: Maybe<Array<Credit>>;
  displayName: Scalars["String"];
  format?: Maybe<Scalars["String"]>;
  id: Scalars["ID"];
  issue?: Maybe<Scalars["String"]>;
  pageCount?: Maybe<Scalars["String"]>;
  price?: Maybe<Scalars["String"]>;
  publicationDate?: Maybe<Scalars["String"]>;
  publisher?: Maybe<Publisher>;
  publisherName?: Maybe<Scalars["String"]>;
  series?: Maybe<Series>;
  seriesName?: Maybe<Scalars["String"]>;
  summary?: Maybe<Scalars["String"]>;
  updatedAt: Scalars["DateTime"];
};

export type BookAttributes = {
  ageRating?: Maybe<Scalars["String"]>;
  alternateTitle?: Maybe<Scalars["String"]>;
  creditIds?: Maybe<Array<Scalars["ID"]>>;
  format?: Maybe<Scalars["String"]>;
  issue?: Maybe<Scalars["String"]>;
  pageCount?: Maybe<Scalars["String"]>;
  price?: Maybe<Scalars["String"]>;
  publicationDate?: Maybe<Scalars["String"]>;
  seriesId?: Maybe<Scalars["ID"]>;
  summary?: Maybe<Scalars["String"]>;
};

/** The connection type for Book. */
export type BookConnection = {
  __typename?: "BookConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BookEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Book>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type BookEdge = {
  __typename?: "BookEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"];
  /** The item at the end of the edge. */
  node?: Maybe<Book>;
};

/** Autogenerated return type of CreateBook */
export type CreateBookPayload = {
  __typename?: "CreateBookPayload";
  book?: Maybe<Book>;
  errors: Array<UserError>;
};

/** Autogenerated return type of CreatePublisher */
export type CreatePublisherPayload = {
  __typename?: "CreatePublisherPayload";
  errors: Array<UserError>;
  publisher?: Maybe<Publisher>;
};

/** A person representing someone involved in the creation process of a book */
export type Creator = {
  __typename?: "Creator";
  createdAt: Scalars["DateTime"];
  firstName?: Maybe<Scalars["String"]>;
  id: Scalars["ID"];
  lastName?: Maybe<Scalars["String"]>;
  updatedAt: Scalars["DateTime"];
};

/** An association of book and creator */
export type Credit = {
  __typename?: "Credit";
  book: Book;
  createdAt: Scalars["DateTime"];
  creator: Creator;
  id: Scalars["ID"];
  role: Scalars["String"];
  updatedAt: Scalars["DateTime"];
};

/** Autogenerated return type of EditBook */
export type EditBookPayload = {
  __typename?: "EditBookPayload";
  book?: Maybe<Book>;
  errors: Array<UserError>;
};

/** Autogenerated return type of Login */
export type LoginPayload = {
  __typename?: "LoginPayload";
  csrf: Scalars["String"];
  expiresAt: Scalars["String"];
  jwt: Scalars["String"];
  refresh: Scalars["String"];
  refreshExpiresAt: Scalars["String"];
  user: User;
};

/** Autogenerated return type of Logout */
export type LogoutPayload = {
  __typename?: "LogoutPayload";
  exit?: Maybe<Scalars["String"]>;
};

export type Mutation = {
  __typename?: "Mutation";
  createBook?: Maybe<CreateBookPayload>;
  createPublisher?: Maybe<CreatePublisherPayload>;
  createSeries?: Maybe<Series>;
  createUser?: Maybe<RegisterPayload>;
  editBook?: Maybe<EditBookPayload>;
  login?: Maybe<LoginPayload>;
  logout?: Maybe<LogoutPayload>;
  refreshSession?: Maybe<RefreshPayload>;
  register?: Maybe<RegisterPayload>;
};

export type MutationCreateBookArgs = {
  attributes: BookAttributes;
};

export type MutationCreatePublisherArgs = {
  name: Scalars["String"];
};

export type MutationCreateSeriesArgs = {
  name: Scalars["String"];
  publisherId: Scalars["ID"];
};

export type MutationCreateUserArgs = {
  email: Scalars["String"];
  password: Scalars["String"];
  name: Scalars["String"];
};

export type MutationEditBookArgs = {
  id: Scalars["ID"];
  attributes: BookAttributes;
};

export type MutationLoginArgs = {
  email: Scalars["String"];
  password: Scalars["String"];
};

export type MutationRegisterArgs = {
  email: Scalars["String"];
  password: Scalars["String"];
  name: Scalars["String"];
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: "PageInfo";
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars["String"]>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars["Boolean"];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars["Boolean"];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars["String"]>;
};

/** A book publishing company */
export type Publisher = {
  __typename?: "Publisher";
  bookCount: Scalars["Int"];
  createdAt: Scalars["DateTime"];
  id: Scalars["ID"];
  name: Scalars["String"];
  series: Array<Series>;
  seriesCount: Scalars["Int"];
  updatedAt: Scalars["DateTime"];
};

/** The connection type for Publisher. */
export type PublisherConnection = {
  __typename?: "PublisherConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PublisherEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Publisher>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PublisherEdge = {
  __typename?: "PublisherEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"];
  /** The item at the end of the edge. */
  node?: Maybe<Publisher>;
};

export type Query = {
  __typename?: "Query";
  book: Book;
  books: BookConnection;
  publisher: Publisher;
  publishers: PublisherConnection;
  series: Series;
  seriesList: SeriesConnection;
};

export type QueryBookArgs = {
  id?: Maybe<Scalars["ID"]>;
};

export type QueryBooksArgs = {
  sortBy?: Maybe<SortAttributes>;
  limit?: Maybe<Scalars["Int"]>;
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

export type QueryPublisherArgs = {
  id?: Maybe<Scalars["ID"]>;
};

export type QueryPublishersArgs = {
  sortBy?: Maybe<SortAttributes>;
  limit?: Maybe<Scalars["Int"]>;
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

export type QuerySeriesArgs = {
  id?: Maybe<Scalars["ID"]>;
};

export type QuerySeriesListArgs = {
  sortBy?: Maybe<SortAttributes>;
  limit?: Maybe<Scalars["Int"]>;
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

/** Autogenerated return type of Refresh */
export type RefreshPayload = {
  __typename?: "RefreshPayload";
  csrf: Scalars["String"];
};

/** Autogenerated return type of Register */
export type RegisterPayload = {
  __typename?: "RegisterPayload";
  user?: Maybe<User>;
};

/** A collection of related books */
export type Series = {
  __typename?: "Series";
  bookCount: Scalars["Int"];
  /** A list of books released in this series */
  books?: Maybe<Array<Book>>;
  id: Scalars["ID"];
  name: Scalars["String"];
  publisher?: Maybe<Publisher>;
  publisherName?: Maybe<Scalars["String"]>;
};

/** A collection of related books */
export type SeriesBooksArgs = {
  limit?: Maybe<Scalars["Int"]>;
};

/** The connection type for Series. */
export type SeriesConnection = {
  __typename?: "SeriesConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SeriesEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Series>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SeriesEdge = {
  __typename?: "SeriesEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"];
  /** The item at the end of the edge. */
  node?: Maybe<Series>;
};

/** Attributes for defining the sorting of the query results */
export type SortAttributes = {
  /** name of the field */
  field: Scalars["String"];
  /** direction of the sort */
  direction: SortDirectionEnum;
};

export enum SortDirectionEnum {
  /** Ascending */
  Asc = "ASC",
  /** Descending */
  Desc = "DESC",
}

/** A website user */
export type User = {
  __typename?: "User";
  avatar: Scalars["String"];
  createdAt: Scalars["DateTime"];
  email: Scalars["String"];
  id: Scalars["ID"];
  name: Scalars["String"];
  updatedAt: Scalars["DateTime"];
};

/** A user-readable error */
export type UserError = {
  __typename?: "UserError";
  /** A description of the error */
  message: Scalars["String"];
  /** Which input value this error came from */
  path?: Maybe<Array<Scalars["String"]>>;
};

export type BooksQueryVariables = Exact<{
  last?: Maybe<Scalars["Int"]>;
}>;

export type BooksQuery = { __typename?: "Query" } & {
  books: { __typename?: "BookConnection" } & {
    nodes?: Maybe<
      Array<
        Maybe<
          { __typename?: "Book" } & Pick<
            Book,
            | "id"
            | "publisherName"
            | "seriesName"
            | "issue"
            | "format"
            | "publicationDate"
            | "price"
            | "pageCount"
          >
        >
      >
    >;
  };
};

export type LoginMutationVariables = Exact<{
  email: Scalars["String"];
  password: Scalars["String"];
}>;

export type LoginMutation = { __typename?: "Mutation" } & {
  login?: Maybe<
    { __typename?: "LoginPayload" } & Pick<
      LoginPayload,
      "csrf" | "jwt" | "refresh" | "refreshExpiresAt"
    > & {
        user: { __typename?: "User" } & Pick<
          User,
          "id" | "name" | "email" | "avatar" | "createdAt" | "updatedAt"
        >;
      }
  >;
};

export type LogoutMutationVariables = Exact<{ [key: string]: never }>;

export type LogoutMutation = { __typename?: "Mutation" } & {
  logout?: Maybe<
    { __typename?: "LogoutPayload" } & Pick<LogoutPayload, "exit">
  >;
};

export type RankedBookListQueryVariables = Exact<{
  limit?: Maybe<Scalars["Int"]>;
  field: Scalars["String"];
  direction: SortDirectionEnum;
}>;

export type RankedBookListQuery = { __typename?: "Query" } & {
  books: { __typename?: "BookConnection" } & {
    nodes?: Maybe<
      Array<
        Maybe<
          { __typename?: "Book" } & Pick<
            Book,
            "id" | "displayName" | "publicationDate" | "publisherName"
          >
        >
      >
    >;
  };
};

export type RankedPublisherListQueryVariables = Exact<{
  limit?: Maybe<Scalars["Int"]>;
  field: Scalars["String"];
  direction: SortDirectionEnum;
}>;

export type RankedPublisherListQuery = { __typename?: "Query" } & {
  publishers: { __typename?: "PublisherConnection" } & {
    nodes?: Maybe<
      Array<
        Maybe<
          { __typename?: "Publisher" } & Pick<
            Publisher,
            "id" | "name" | "seriesCount"
          >
        >
      >
    >;
  };
};

export type RankedSeriesListQueryVariables = Exact<{
  limit?: Maybe<Scalars["Int"]>;
  field: Scalars["String"];
  direction: SortDirectionEnum;
}>;

export type RankedSeriesListQuery = { __typename?: "Query" } & {
  seriesList: { __typename?: "SeriesConnection" } & {
    nodes?: Maybe<
      Array<
        Maybe<
          { __typename?: "Series" } & Pick<
            Series,
            "id" | "name" | "publisherName" | "bookCount"
          >
        >
      >
    >;
  };
};

export type RegisterMutationVariables = Exact<{
  name: Scalars["String"];
  email: Scalars["String"];
  password: Scalars["String"];
}>;

export type RegisterMutation = { __typename?: "Mutation" } & {
  register?: Maybe<
    { __typename?: "RegisterPayload" } & {
      user?: Maybe<{ __typename?: "User" } & Pick<User, "id">>;
    }
  >;
};

export const BooksDocument = gql`
  query Books($last: Int) {
    books(last: $last) {
      nodes {
        id
        publisherName
        seriesName
        issue
        format
        publicationDate
        price
        pageCount
      }
    }
  }
`;

/**
 * __useBooksQuery__
 *
 * To run a query within a React component, call `useBooksQuery` and pass it any options that fit your needs.
 * When your component renders, `useBooksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBooksQuery({
 *   variables: {
 *      last: // value for 'last'
 *   },
 * });
 */
export function useBooksQuery(
  baseOptions?: Apollo.QueryHookOptions<BooksQuery, BooksQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<BooksQuery, BooksQueryVariables>(
    BooksDocument,
    options
  );
}
export function useBooksLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<BooksQuery, BooksQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<BooksQuery, BooksQueryVariables>(
    BooksDocument,
    options
  );
}
export type BooksQueryHookResult = ReturnType<typeof useBooksQuery>;
export type BooksLazyQueryHookResult = ReturnType<typeof useBooksLazyQuery>;
export type BooksQueryResult = Apollo.QueryResult<
  BooksQuery,
  BooksQueryVariables
>;
export const LoginDocument = gql`
  mutation Login($email: String!, $password: String!) {
    login(email: $email, password: $password) {
      csrf
      jwt
      refresh
      refreshExpiresAt
      user {
        id
        name
        email
        avatar
        createdAt
        updatedAt
      }
    }
  }
`;
export type LoginMutationFn = Apollo.MutationFunction<
  LoginMutation,
  LoginMutationVariables
>;

/**
 * __useLoginMutation__
 *
 * To run a mutation, you first call `useLoginMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLoginMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [loginMutation, { data, loading, error }] = useLoginMutation({
 *   variables: {
 *      email: // value for 'email'
 *      password: // value for 'password'
 *   },
 * });
 */
export function useLoginMutation(
  baseOptions?: Apollo.MutationHookOptions<
    LoginMutation,
    LoginMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<LoginMutation, LoginMutationVariables>(
    LoginDocument,
    options
  );
}
export type LoginMutationHookResult = ReturnType<typeof useLoginMutation>;
export type LoginMutationResult = Apollo.MutationResult<LoginMutation>;
export type LoginMutationOptions = Apollo.BaseMutationOptions<
  LoginMutation,
  LoginMutationVariables
>;
export const LogoutDocument = gql`
  mutation Logout {
    logout {
      exit
    }
  }
`;
export type LogoutMutationFn = Apollo.MutationFunction<
  LogoutMutation,
  LogoutMutationVariables
>;

/**
 * __useLogoutMutation__
 *
 * To run a mutation, you first call `useLogoutMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLogoutMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [logoutMutation, { data, loading, error }] = useLogoutMutation({
 *   variables: {
 *   },
 * });
 */
export function useLogoutMutation(
  baseOptions?: Apollo.MutationHookOptions<
    LogoutMutation,
    LogoutMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<LogoutMutation, LogoutMutationVariables>(
    LogoutDocument,
    options
  );
}
export type LogoutMutationHookResult = ReturnType<typeof useLogoutMutation>;
export type LogoutMutationResult = Apollo.MutationResult<LogoutMutation>;
export type LogoutMutationOptions = Apollo.BaseMutationOptions<
  LogoutMutation,
  LogoutMutationVariables
>;
export const RankedBookListDocument = gql`
  query RankedBookList(
    $limit: Int
    $field: String!
    $direction: SortDirectionEnum!
  ) {
    books(limit: $limit, sortBy: { field: $field, direction: $direction }) {
      nodes {
        id
        displayName
        publicationDate
        publisherName
      }
    }
  }
`;

/**
 * __useRankedBookListQuery__
 *
 * To run a query within a React component, call `useRankedBookListQuery` and pass it any options that fit your needs.
 * When your component renders, `useRankedBookListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRankedBookListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      field: // value for 'field'
 *      direction: // value for 'direction'
 *   },
 * });
 */
export function useRankedBookListQuery(
  baseOptions: Apollo.QueryHookOptions<
    RankedBookListQuery,
    RankedBookListQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<RankedBookListQuery, RankedBookListQueryVariables>(
    RankedBookListDocument,
    options
  );
}
export function useRankedBookListLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RankedBookListQuery,
    RankedBookListQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<RankedBookListQuery, RankedBookListQueryVariables>(
    RankedBookListDocument,
    options
  );
}
export type RankedBookListQueryHookResult = ReturnType<
  typeof useRankedBookListQuery
>;
export type RankedBookListLazyQueryHookResult = ReturnType<
  typeof useRankedBookListLazyQuery
>;
export type RankedBookListQueryResult = Apollo.QueryResult<
  RankedBookListQuery,
  RankedBookListQueryVariables
>;
export const RankedPublisherListDocument = gql`
  query RankedPublisherList(
    $limit: Int
    $field: String!
    $direction: SortDirectionEnum!
  ) {
    publishers(
      limit: $limit
      sortBy: { field: $field, direction: $direction }
    ) {
      nodes {
        id
        name
        seriesCount
      }
    }
  }
`;

/**
 * __useRankedPublisherListQuery__
 *
 * To run a query within a React component, call `useRankedPublisherListQuery` and pass it any options that fit your needs.
 * When your component renders, `useRankedPublisherListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRankedPublisherListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      field: // value for 'field'
 *      direction: // value for 'direction'
 *   },
 * });
 */
export function useRankedPublisherListQuery(
  baseOptions: Apollo.QueryHookOptions<
    RankedPublisherListQuery,
    RankedPublisherListQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    RankedPublisherListQuery,
    RankedPublisherListQueryVariables
  >(RankedPublisherListDocument, options);
}
export function useRankedPublisherListLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RankedPublisherListQuery,
    RankedPublisherListQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    RankedPublisherListQuery,
    RankedPublisherListQueryVariables
  >(RankedPublisherListDocument, options);
}
export type RankedPublisherListQueryHookResult = ReturnType<
  typeof useRankedPublisherListQuery
>;
export type RankedPublisherListLazyQueryHookResult = ReturnType<
  typeof useRankedPublisherListLazyQuery
>;
export type RankedPublisherListQueryResult = Apollo.QueryResult<
  RankedPublisherListQuery,
  RankedPublisherListQueryVariables
>;
export const RankedSeriesListDocument = gql`
  query RankedSeriesList(
    $limit: Int
    $field: String!
    $direction: SortDirectionEnum!
  ) {
    seriesList(
      limit: $limit
      sortBy: { field: $field, direction: $direction }
    ) {
      nodes {
        id
        name
        publisherName
        bookCount
      }
    }
  }
`;

/**
 * __useRankedSeriesListQuery__
 *
 * To run a query within a React component, call `useRankedSeriesListQuery` and pass it any options that fit your needs.
 * When your component renders, `useRankedSeriesListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRankedSeriesListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      field: // value for 'field'
 *      direction: // value for 'direction'
 *   },
 * });
 */
export function useRankedSeriesListQuery(
  baseOptions: Apollo.QueryHookOptions<
    RankedSeriesListQuery,
    RankedSeriesListQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<RankedSeriesListQuery, RankedSeriesListQueryVariables>(
    RankedSeriesListDocument,
    options
  );
}
export function useRankedSeriesListLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RankedSeriesListQuery,
    RankedSeriesListQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    RankedSeriesListQuery,
    RankedSeriesListQueryVariables
  >(RankedSeriesListDocument, options);
}
export type RankedSeriesListQueryHookResult = ReturnType<
  typeof useRankedSeriesListQuery
>;
export type RankedSeriesListLazyQueryHookResult = ReturnType<
  typeof useRankedSeriesListLazyQuery
>;
export type RankedSeriesListQueryResult = Apollo.QueryResult<
  RankedSeriesListQuery,
  RankedSeriesListQueryVariables
>;
export const RegisterDocument = gql`
  mutation Register($name: String!, $email: String!, $password: String!) {
    register(name: $name, email: $email, password: $password) {
      user {
        id
      }
    }
  }
`;
export type RegisterMutationFn = Apollo.MutationFunction<
  RegisterMutation,
  RegisterMutationVariables
>;

/**
 * __useRegisterMutation__
 *
 * To run a mutation, you first call `useRegisterMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRegisterMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [registerMutation, { data, loading, error }] = useRegisterMutation({
 *   variables: {
 *      name: // value for 'name'
 *      email: // value for 'email'
 *      password: // value for 'password'
 *   },
 * });
 */
export function useRegisterMutation(
  baseOptions?: Apollo.MutationHookOptions<
    RegisterMutation,
    RegisterMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<RegisterMutation, RegisterMutationVariables>(
    RegisterDocument,
    options
  );
}
export type RegisterMutationHookResult = ReturnType<typeof useRegisterMutation>;
export type RegisterMutationResult = Apollo.MutationResult<RegisterMutation>;
export type RegisterMutationOptions = Apollo.BaseMutationOptions<
  RegisterMutation,
  RegisterMutationVariables
>;
